using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
//using System.Runtime.InteropServices;
using System.Text;
using System.Linq;


/// <summary>
/// Facetracking manager is the component that manages the head and face tracking.
/// </summary>
public class FacetrackingWithUVs: MonoBehaviour 
{
	public Mesh pregenFace;

	public Texture2D[] faceImages;

	private int startNumber = 0;

	private double[] finalUVs = {0.5249623, 0.6137605, 0.524815, 0.6138977, 0.5241948, 0.6161117, 0.523805, 0.6140409, 0.5237895, 0.6027625, 0.523244, 0.5900758, 0.5230284, 0.5837364, 0.5229825, 0.5746248, 0.5225312, 0.5740718, 0.521844, 0.5646847, 0.5199369, 0.5569303, 0.5220523, 0.4165224, 0.5219039, 0.439684, 0.5220643, 0.4551062, 0.5215987, 0.4965859, 0.5213596, 0.5126367, 0.5221671, 0.3907896, 0.5220734, 0.478081, 0.5224021, 0.4711544, 0.5214077, 0.5218351, 0.5209976, 0.4905914, 0.5217062, 0.4837162, 0.5213206, 0.5278059, 0.5213289, 0.4927806, 0.5219811, 0.4065366, 0.5220122, 0.4489026, 0.5223743, 0.4630442, 0.5223215, 0.3756964, 0.5216088, 0.3323247, 0.5215146, 0.2893448, 0.521535, 0.3097621, 0.5211495, 0.4879746, 0.5218368, 0.5031688, 0.5230421, 0.5781817, 0.5244617, 0.6159322, 0.5221447, 0.4244848, 0.4617176, 0.4613923, 0.462369, 0.493094, 0.4830236, 0.5769118, 0.4913493, 0.590605, 0.4911936, 0.5864217, 0.4834334, 0.5725216, 0.4988457, 0.5945402, 0.4939081, 0.5948424, 0.4758777, 0.565924, 0.5035436, 0.5877492, 0.4918188, 0.5800368, 0.4849164, 0.5772819, 0.4766379, 0.560907, 0.4976611, 0.5757639, 0.4772256, 0.5586928, 0.4862343, 0.5640156, 0.4663177, 0.540715, 0.4857499, 0.517056, 0.4923817, 0.5257863, 0.4909139, 0.5484614, 0.4832123, 0.5432818, 0.46598, 0.5356586, 0.5053523, 0.5826213, 0.4933566, 0.5622993, 0.5059813, 0.5782781, 0.4990874, 0.5712112, 0.5076431, 0.5647922, 0.4996462, 0.56795, 0.4584006, 0.4560088, 0.4601111, 0.5071675, 0.5027953, 0.559316, 0.4977449, 0.5595169, 0.496096, 0.5608492, 0.4937176, 0.5506736, 0.5075881, 0.5617384, 0.5006471, 0.5559146, 0.494995, 0.5516923, 0.4962329, 0.446194, 0.4960018, 0.4546669, 0.5082363, 0.5583017, 0.5037549, 0.5572029, 0.4991919, 0.5518512, 0.4966389, 0.5326146, 0.4949313, 0.5288811, 0.5087684, 0.5549383, 0.5041465, 0.5550173, 0.5015329, 0.5541137, 0.4994189, 0.5396715, 0.4986134, 0.5210463, 0.503823, 0.4500976, 0.5034248, 0.4688025, 0.4792222, 0.462147, 0.474045, 0.4444912, 0.5046483, 0.5536357, 0.5022905, 0.5524437, 0.5002652, 0.5513132, 0.5002607, 0.5264336, 0.5017904, 0.4853112, 0.5031604, 0.4367174, 0.5038682, 0.4436184, 0.4953968, 0.4394877, 0.5025448, 0.5517887, 0.5012541, 0.5507055, 0.5008853, 0.5419887, 0.4803009, 0.4398643, 0.4777249, 0.4366011, 0.4621241, 0.4107635, 0.5016775, 0.550175, 0.5018821, 0.5438352, 0.5020681, 0.5325473, 0.5146112, 0.427984, 0.5141892, 0.4439301, 0.5090373, 0.4535647, 0.5061194, 0.4311063, 0.5068187, 0.4375469, 0.4988783, 0.4369622, 0.4951181, 0.4311726, 0.4950905, 0.423727, 0.4656965, 0.4354497, 0.4699537, 0.42904, 0.5029096, 0.5453404, 0.5056373, 0.5303675, 0.5033718, 0.4770898, 0.5152532, 0.4196546, 0.5181407, 0.4176541, 0.4960144, 0.407683, 0.4827752, 0.4303281, 0.4849473, 0.4234661, 0.4701016, 0.4126562, 0.4648679, 0.3931075, 0.4560546, 0.4439374, 0.4558891, 0.4466576, 0.4569965, 0.4020278, 0.4560818, 0.4322963, 0.50666, 0.5337198, 0.5103655, 0.4988287, 0.502518, 0.4823646, 0.5034633, 0.4781489, 0.5056495, 0.4714587, 0.5072359, 0.421276, 0.4982405, 0.429658, 0.4844346, 0.4095661, 0.4735552, 0.4123545, 0.4710582, 0.4036255, 0.4673885, 0.3995394, 0.4568145, 0.4006607, 0.4585102, 0.4046104, 0.5077163, 0.5396289, 0.5135714, 0.5128708, 0.5027079, 0.4894283, 0.5042297, 0.4859514, 0.5055733, 0.4741036, 0.5105355, 0.4619247, 0.513415, 0.4584076, 0.5176643, 0.4408641, 0.5099347, 0.4232138, 0.5132585, 0.413644, 0.4985231, 0.4089333, 0.4613525, 0.3776166, 0.5135812, 0.5220248, 0.5049965, 0.4933938, 0.5060898, 0.4897545, 0.5058643, 0.4876723, 0.5051772, 0.4791535, 0.5057091, 0.4825954, 0.5111646, 0.3993281, 0.5148478, 0.3939806, 0.4686822, 0.3936625, 0.4728715, 0.399299, 0.5154809, 0.5269607, 0.5169022, 0.5121694, 0.5186149, 0.4964454, 0.5073788, 0.4847849, 0.5109912, 0.4740652, 0.5146506, 0.4723783, 0.5154333, 0.4785134, 0.511865, 0.4788991, 0.5174161, 0.456052, 0.4773401, 0.4123692, 0.4746097, 0.4053188, 0.467454, 0.3860095, 0.4637521, 0.3577028, 0.4646942, 0.3659877, 0.5146576, 0.5366627, 0.513046, 0.4827252, 0.5154646, 0.4834383, 0.5175577, 0.4892676, 0.5174636, 0.3919179, 0.5094649, 0.4103233, 0.4999735, 0.4208876, 0.5007583, 0.4271697, 0.5004525, 0.4111886, 0.4814219, 0.411611, 0.47802, 0.3998547, 0.515459, 0.5553796, 0.5163345, 0.5211231, 0.518764, 0.4716908, 0.518747, 0.4782565, 0.4993705, 0.3921876, 0.4991855, 0.3820322, 0.5047426, 0.4193484, 0.502823, 0.417096, 0.4801755, 0.418687, 0.479095, 0.4061699, 0.4769166, 0.3823214, 0.4791552, 0.3905526, 0.5180384, 0.5273954, 0.5143037, 0.4917965, 0.5171853, 0.4912555, 0.5163291, 0.489704, 0.5187173, 0.483835, 0.5191603, 0.4903166, 0.5007943, 0.3715028, 0.4989618, 0.3982717, 0.5026037, 0.4148593, 0.4829126, 0.4104443, 0.4808539, 0.4045315, 0.4815013, 0.3690565, 0.4637704, 0.3490023, 0.5170619, 0.5367419, 0.5191299, 0.4923204, 0.4938385, 0.3807211, 0.4946922, 0.3680847, 0.4954425, 0.3898602, 0.5043712, 0.4145704, 0.4816105, 0.3968467, 0.4811269, 0.3766017, 0.4842965, 0.387544, 0.4874598, 0.3675607, 0.5179467, 0.5566414, 0.490027, 0.3883728, 0.4873025, 0.3782234, 0.4952846, 0.3956761, 0.4981421, 0.4028713, 0.4983708, 0.4062336, 0.4729441, 0.3361677, 0.4720229, 0.324422, 0.4913496, 0.3943498, 0.4842994, 0.4020814, 0.4866041, 0.3946428, 0.4952158, 0.4010752, 0.4956385, 0.4045255, 0.4869762, 0.4079811, 0.479616, 0.3265513, 0.4924223, 0.4000266, 0.4930826, 0.4065922, 0.4928624, 0.4036536, 0.4886606, 0.4005279, 0.4899381, 0.4065614, 0.4786013, 0.3134032, 0.485901, 0.304885, 0.4930409, 0.2985453, 0.5005778, 0.3124421, 0.4939485, 0.3161174, 0.4996272, 0.2939265, 0.5078756, 0.3325673, 0.5008499, 0.3334778, 0.4940539, 0.3345944, 0.4875222, 0.3367315, 0.4809221, 0.3413118, 0.4738093, 0.3491966, 0.5154975, 0.4103635, 0.517888, 0.4073625, 0.5023427, 0.4325324, 0.5099488, 0.4307897, 0.5061336, 0.4606004, 0.5049803, 0.4981758, 0.5063688, 0.5184839, 0.5081103, 0.5257438, 0.4873088, 0.4242678, 0.4851134, 0.4319029, 0.4835376, 0.4413989, 0.481448, 0.4498271, 0.4845639, 0.4617487, 0.5126999, 0.5276066, 0.5124699, 0.5363866, 0.5130277, 0.5541928, 0.4667538, 0.5276311, 0.4729795, 0.5340733, 0.4593903, 0.5139573, 0.4584108, 0.5019401, 0.4719324, 0.5198368, 0.4748102, 0.4279096, 0.4790908, 0.4247209, 0.4596439, 0.4478347, 0.4866285, 0.3201668, 0.5146063, 0.3099875, 0.5065653, 0.4683991, 0.5108813, 0.4570284, 0.5134962, 0.4533384, 0.517343, 0.4506007, 0.4804762, 0.4128273, 0.4806641, 0.4279525, 0.4756584, 0.4321785, 0.47169, 0.4397073, 0.4659727, 0.4429055, 0.5110021, 0.4671491, 0.5144743, 0.4644694, 0.5187326, 0.463046, 0.5142649, 0.2896699, 0.5032268, 0.494116, 0.5031511, 0.476753, 0.5065727, 0.4144865, 0.4949354, 0.4901302, 0.4984068, 0.4998384, 0.4995555, 0.5040271, 0.490337, 0.4589842, 0.4909905, 0.4487826, 0.4913901, 0.4410362, 0.4917895, 0.4318639, 0.511103, 0.4936607, 0.5012204, 0.5091495, 0.5026858, 0.5170599, 0.5038974, 0.5251191, 0.5035223, 0.5366312, 0.5041739, 0.5394096, 0.504912, 0.5421072, 0.5066994, 0.5547149, 0.5046682, 0.4267138, 0.5031031, 0.4227711, 0.5019245, 0.413328, 0.5164022, 0.488336, 0.5149337, 0.4955851, 0.509554, 0.4824717, 0.5082279, 0.4942164, 0.5187426, 0.4879328, 0.5164379, 0.4869206, 0.5150598, 0.486073, 0.5144666, 0.486767, 0.4816898, 0.4087069, 0.4831769, 0.4075997, 0.486125, 0.4055208, 0.4896842, 0.4038134, 0.5029179, 0.4145032, 0.5019817, 0.4183519, 0.4978346, 0.4230284, 0.4924857, 0.4240114, 0.4828047, 0.4224557, 0.4761223, 0.4028178, 0.4674823, 0.3365966, 0.4677913, 0.3460017, 0.4684197, 0.3564869, 0.4713822, 0.3798767, 0.4726705, 0.3875215, 0.4757224, 0.3948924, 0.4805283, 0.4102492, 0.4777321, 0.4076199, 0.4812747, 0.4206949, 0.5132515, 0.3757454, 0.507017, 0.3755827, 0.5030479, 0.3841878, 0.5026472, 0.3946272, 0.5015358, 0.4017434, 0.5008243, 0.4055899, 0.5009178, 0.4090554, 0.4967792, 0.516641, 0.4946846, 0.5132371, 0.4900263, 0.5033951, 0.4889768, 0.4692845, 0.519922, 0.5646161, 0.5199913, 0.5739249, 0.520507, 0.5745853, 0.5198451, 0.5839657, 0.5203378, 0.5904161, 0.5200631, 0.6027859, 0.5189255, 0.6137555, 0.5182833, 0.6155467, 0.5180128, 0.613212, 0.5178332, 0.6126211, 0.5173424, 0.5636449, 0.5171899, 0.5719082, 0.517426, 0.5739561, 0.5170581, 0.584278, 0.5170297, 0.5909278, 0.5158604, 0.601676, 0.5140186, 0.61231, 0.512535, 0.6136911, 0.5119427, 0.6104106, 0.5113777, 0.6086848, 0.515053, 0.5624907, 0.5144534, 0.5690028, 0.5144474, 0.5721607, 0.5141499, 0.5842991, 0.5137845, 0.5906478, 0.5115713, 0.5995639, 0.5084958, 0.608984, 0.5066925, 0.6091254, 0.5049607, 0.605094, 0.5046748, 0.602882, 0.5059224, 0.5564345, 0.5051639, 0.5586277, 0.5040839, 0.5612193, 0.5021514, 0.5773583, 0.5005604, 0.5817646, 0.4951779, 0.5868658, 0.4899964, 0.5862322, 0.4838168, 0.5814291, 0.5106152, 0.5060914, 0.5145648, 0.5033836, 0.5180723, 0.5029518, 0.4977378, 0.536455, 0.4969516, 0.5521116, 0.4994551, 0.5578467, 0.5009719, 0.56409, 0.5029796, 0.5680665, 0.5066799, 0.5721136, 0.5138705, 0.5774964, 0.5174018, 0.5781893, 0.5201749, 0.5782699, 0.5178756, 0.6150006, 0.5121168, 0.6128527, 0.5053954, 0.6083353, 0.4921273, 0.5931805, 0.4860788, 0.5848002, 0.4799634, 0.5748721, 0.472269, 0.5537615, 0.4686226, 0.5131179, 0.4717828, 0.4722627, 0.474404, 0.4602528, 0.4771299, 0.4480231, 0.47724, 0.5708655, 0.4678927, 0.5471236, 0.4633681, 0.5200491, 0.4626933, 0.506551, 0.4673991, 0.4668835, 0.4961079, 0.5555011, 0.4943676, 0.5554705, 0.4916897, 0.5547398, 0.4845776, 0.5538557, 0.4752581, 0.5470915, 0.4684889, 0.5416376, 0.464892, 0.5336301, 0.4608544, 0.524547, 0.4614931, 0.5215322, 0.4982217, 0.5548772, 0.4998609, 0.5539271, 0.5008414, 0.5526023, 0.501388, 0.5515242, 0.5016798, 0.5508222, 0.4675787, 0.4498692, 0.4780854, 0.4215903, 0.4704552, 0.4346183, 0.4741954, 0.4230984, 0.477508, 0.4192356, 0.4800066, 0.4138267, 0.4793486, 0.416976, 0.479012, 0.4131644, 0.5147436, 0.3322511, 0.507584, 0.3108811, 0.5068151, 0.2910326, 0.5180364, 0.4256849, 0.5096989, 0.4378752, 0.5068128, 0.4445255, 0.4950599, 0.4633572, 0.4826617, 0.473204, 0.4763348, 0.4739807, 0.4637858, 0.4598303, 0.4618456, 0.4500236, 0.4760758, 0.3736142, 0.4587519, 0.5088098, 0.4579455, 0.4583138, 0.4587081, 0.4596903, 0.4702653, 0.4561219, 0.4616376, 0.4408053, 0.4599606, 0.3709594, 0.4553112, 0.4456855, 0.4602065, 0.3638417, 0.4660645, 0.412439, 0.4858418, 0.4501743, 0.4868775, 0.44192, 0.4882661, 0.4324348, 0.4899012, 0.4245027, 0.5035301, 0.4822588, 0.4795345, 0.4153087, 0.4790106, 0.4156201, 0.4770628, 0.4169278, 0.4735687, 0.4193423, 0.4697802, 0.4234298, 0.4656978, 0.4280561, 0.4615904, 0.4311949, 0.455397, 0.4326431, 0.4556687, 0.4329096, 0.4590458, 0.4335019, 0.4998966, 0.4783734, 0.5000366, 0.4568147, 0.5006037, 0.4493872, 0.4998735, 0.4422899, 0.5063518, 0.5093892, 0.5102564, 0.515343, 0.5110633, 0.5234532, 0.5041771, 0.4892818, 0.5026866, 0.4825006, 0.512684, 0.4236919, 0.512358, 0.4318679, 0.5115027, 0.4478911, 0.5082281, 0.4622784, 0.5086091, 0.4663547, 0.5089096, 0.4701484, 0.508755, 0.4759906, 0.5085436, 0.4798135, 0.5217843, 0.3549003, 0.5143098, 0.3542351, 0.5070906, 0.3534963, 0.4998181, 0.352935, 0.4933008, 0.3530325, 0.4873353, 0.3540837, 0.4810993, 0.3562925, 0.4748689, 0.3626029, 0.4695394, 0.3690417, 0.4651482, 0.3750585, 0.4627835, 0.3839293, 0.4594985, 0.407294, 0.5029782, 0.4866293, 0.4982907, 0.5956357, 0.4982493, 0.5983401, 0.4988253, 0.6013231, 0.5002525, 0.6021789, 0.5031329, 0.6032098, 0.507064, 0.5950426, 0.5093192, 0.5881572, 0.5101092, 0.5816128, 0.510219, 0.5753757, 0.51126, 0.5692593, 0.5115129, 0.5658694, 0.5114052, 0.5603207, 0.5106214, 0.554234, 0.5103188, 0.5369202, 0.5092715, 0.5294624, 0.5064744, 0.4920988, 0.5117809, 0.4865722, 0.4584624, 0.4972928, 0.458646, 0.4956041, 0.4908737, 0.5831116, 0.5175921, 0.6125662, 0.5108593, 0.6083352, 0.5250308, 0.61384, 0.504074, 0.6018544, 0.4974171, 0.5931754, 0.5022328, 0.5736619, 0.4592875, 0.3898748, 0.4577621, 0.3859263, 0.4569344, 0.3822613, 0.4795492, 0.4116158, 0.477513, 0.4102042, 0.4740301, 0.408545, 0.4705363, 0.4080636, 0.4668621, 0.4057615, 0.463155, 0.4013276, 0.4610114, 0.3940565, 0.4586826, 0.4203202, 0.4563252, 0.4191327, 0.4559185, 0.4183513, 0.4585056, 0.41807, 0.4791358, 0.4144434, 0.4772595, 0.4148124, 0.4733699, 0.4158501, 0.4697826, 0.4178571, 0.4655934, 0.4203438, 0.4614812, 0.421629, 0.550155, 0.5864494, 0.5555855, 0.585839, 0.5587595, 0.5770537, 0.5528469, 0.5798615, 0.5285012, 0.613724, 0.5299542, 0.6154676, 0.5357726, 0.6135499, 0.5338764, 0.6121536, 0.544542, 0.5814005, 0.5470647, 0.5755531, 0.561125, 0.5746014, 0.5634399, 0.5705881, 0.5693491, 0.5471877, 0.5665024, 0.5538356, 0.5276036, 0.6027124, 0.5314593, 0.6015468, 0.538974, 0.6087697, 0.5411104, 0.6089177, 0.5466244, 0.6019052, 0.5435759, 0.6029097, 0.542451, 0.5770825, 0.5451574, 0.5710321, 0.5569031, 0.5641462, 0.5629444, 0.5587755, 0.5647699, 0.5473589, 0.5576792, 0.5542583, 0.5718971, 0.5339634, 0.56894, 0.5420091, 0.5262707, 0.5904035, 0.529536, 0.590777, 0.5353019, 0.5993932, 0.5394471, 0.5948031, 0.5472902, 0.5941493, 0.5421094, 0.5874154, 0.5501369, 0.5624651, 0.5560431, 0.5180019, 0.5498654, 0.5264613, 0.5513728, 0.5490538, 0.5582258, 0.5439153, 0.5711529, 0.5408333, 0.5725175, 0.5359246, 0.5757945, 0.5220135, 0.5753764, 0.5249915, 0.5325657, 0.5904033, 0.5364577, 0.5879197, 0.5513321, 0.5551234, 0.5427944, 0.5641233, 0.5408944, 0.5681366, 0.5418383, 0.5735717, 0.5440595, 0.5678531, 0.5475982, 0.5609929, 0.5486364, 0.5557922, 0.5258354, 0.5783552, 0.5262329, 0.5837155, 0.5290784, 0.5841749, 0.5287567, 0.5783517, 0.5488631, 0.5511464, 0.5789678, 0.4981325, 0.5831059, 0.4595013, 0.5819484, 0.4571849, 0.5774048, 0.5027109, 0.5313854, 0.5772744, 0.5318023, 0.5842444, 0.5352913, 0.5814552, 0.5350071, 0.5753455, 0.5383875, 0.5782162, 0.538072, 0.5723709, 0.5365027, 0.5589972, 0.5391138, 0.5612777, 0.5400496, 0.5593226, 0.5383171, 0.557433, 0.5458914, 0.5596992, 0.5439631, 0.5580556, 0.5476027, 0.5295416, 0.5520265, 0.5040922, 0.548088, 0.5139989, 0.5249364, 0.5740052, 0.5254188, 0.5746502, 0.5283582, 0.5739794, 0.5277777, 0.5719286, 0.5468661, 0.5558749, 0.54447, 0.5552415, 0.5463123, 0.5173135, 0.5443432, 0.5005407, 0.5476607, 0.4906744, 0.5466607, 0.4466232, 0.5467759, 0.4551272, 0.5522254, 0.4595538, 0.5515512, 0.4493041, 0.5304875, 0.569167, 0.5312005, 0.5722535, 0.5341212, 0.5691773, 0.532914, 0.5659241, 0.5365961, 0.5649139, 0.5350212, 0.5618789, 0.534013, 0.5567008, 0.5360865, 0.5554043, 0.5421149, 0.5562661, 0.5407335, 0.5544304, 0.5448264, 0.5525335, 0.547337, 0.5521595, 0.5453837, 0.533152, 0.5434548, 0.5369215, 0.5433137, 0.5047385, 0.5238242, 0.5646486, 0.5264161, 0.5636928, 0.5330532, 0.5549616, 0.5347995, 0.5539833, 0.5426409, 0.5543458, 0.5406587, 0.5529945, 0.5424005, 0.5270609, 0.5443583, 0.5215936, 0.5417529, 0.5096997, 0.5390933, 0.4691096, 0.539251, 0.4503383, 0.5363056, 0.4447129, 0.5365272, 0.4608256, 0.5513306, 0.4416264, 0.5476124, 0.4399113, 0.5719053, 0.4570442, 0.568198, 0.4453559, 0.5646526, 0.4488976, 0.5679028, 0.4611005, 0.521993, 0.5566859, 0.5244797, 0.5554737, 0.5287321, 0.5626175, 0.5311024, 0.5603361, 0.53287, 0.558508, 0.5384243, 0.5526643, 0.5425289, 0.5522534, 0.54131, 0.5401992, 0.5385755, 0.5426058, 0.5405939, 0.5517637, 0.5391535, 0.4438634, 0.5396044, 0.4370257, 0.5365466, 0.4313212, 0.5362133, 0.4376996, 0.5512851, 0.4323905, 0.5482239, 0.4314796, 0.5555002, 0.4425173, 0.5544521, 0.4330523, 0.5646781, 0.4374572, 0.5621801, 0.4406781, 0.5266299, 0.5546164, 0.5286371, 0.5543823, 0.5309681, 0.5550866, 0.5381925, 0.5523217, 0.5393075, 0.5519388, 0.5402253, 0.533006, 0.5381372, 0.5371473, 0.5404686, 0.4328559, 0.5431296, 0.4426354, 0.5437801, 0.437336, 0.5380244, 0.5513797, 0.5386399, 0.5511523, 0.5364851, 0.5442788, 0.5305248, 0.431973, 0.5311468, 0.448079, 0.5335996, 0.4537296, 0.5333371, 0.4380055, 0.5448788, 0.4300697, 0.5420836, 0.4275252, 0.5766838, 0.4364968, 0.5728074, 0.4299983, 0.5720876, 0.4355303, 0.5763617, 0.4438843, 0.5378723, 0.5505347, 0.5352421, 0.5456927, 0.535939, 0.539752, 0.5278691, 0.4197471, 0.5256103, 0.4176084, 0.5255131, 0.4257425, 0.5283159, 0.4280881, 0.5467625, 0.4081209, 0.5482048, 0.4241937, 0.5505804, 0.4245322, 0.5498516, 0.4070755, 0.5532408, 0.42508, 0.552718, 0.4070833, 0.5684969, 0.4239741, 0.5678176, 0.42874, 0.5722126, 0.4135711, 0.5726755, 0.4187948, 0.5766792, 0.4213614, 0.5758353, 0.4133946, 0.5330865, 0.542374, 0.5406883, 0.4856332, 0.539703, 0.4770868, 0.5394912, 0.4774732, 0.5399733, 0.4827524, 0.5384308, 0.4826052, 0.5390533, 0.4785078, 0.5373923, 0.4743933, 0.5371158, 0.4794529, 0.5585074, 0.4101789, 0.5581625, 0.4242721, 0.560077, 0.4230132, 0.5601577, 0.4111303, 0.564954, 0.4200115, 0.564243, 0.4223852, 0.5708705, 0.4045151, 0.5717584, 0.4089663, 0.5751212, 0.4066895, 0.5743258, 0.4004583, 0.5359686, 0.5188051, 0.5324542, 0.5155832, 0.5314873, 0.5237381, 0.5346503, 0.5260319, 0.5394176, 0.4897542, 0.5394232, 0.4944267, 0.5320834, 0.4620725, 0.5293639, 0.458559, 0.5294544, 0.4646358, 0.5322025, 0.4673937, 0.5259886, 0.4409253, 0.5289161, 0.44399, 0.5297799, 0.413969, 0.5327118, 0.423479, 0.5327243, 0.410917, 0.5316375, 0.3994854, 0.5454112, 0.4234415, 0.5441979, 0.4092887, 0.5421423, 0.4115349, 0.5427412, 0.4212494, 0.5675179, 0.4062402, 0.5680888, 0.4094529, 0.5734833, 0.3945612, 0.5692327, 0.4001524, 0.5372431, 0.4937085, 0.5356342, 0.4924423, 0.5340587, 0.4945082, 0.5376001, 0.4985333, 0.5357019, 0.4900873, 0.5359281, 0.4880053, 0.5340785, 0.4850729, 0.5296431, 0.4724408, 0.5324802, 0.4742185, 0.5288448, 0.3943368, 0.5277406, 0.4105523, 0.5662022, 0.4036972, 0.5258351, 0.5123305, 0.5293579, 0.5132903, 0.528641, 0.5035191, 0.5252038, 0.5030673, 0.5286686, 0.4786588, 0.5312303, 0.479131, 0.5261282, 0.4561342, 0.5260507, 0.4631245, 0.5405731, 0.3851848, 0.5372721, 0.3759921, 0.5638822, 0.407097, 0.564992, 0.4085593, 0.5666953, 0.3956604, 0.5641618, 0.4006773, 0.52752, 0.5267792, 0.5247973, 0.5368458, 0.5270078, 0.5366862, 0.5295583, 0.5276951, 0.5260231, 0.5211655, 0.5286668, 0.5222684, 0.5289451, 0.4828847, 0.5266502, 0.4862093, 0.5262057, 0.4717633, 0.5265934, 0.3921475, 0.525956, 0.4074826, 0.5398918, 0.3956618, 0.5620208, 0.405438, 0.525631, 0.4783491, 0.5310685, 0.3760531, 0.543258, 0.393212, 0.5446581, 0.3831298, 0.5410922, 0.4025021, 0.543871, 0.3991719, 0.5699034, 0.3883855, 0.5251441, 0.5276486, 0.5254665, 0.4913158, 0.5263022, 0.4898455, 0.5259985, 0.4883505, 0.5250393, 0.4893612, 0.5257013, 0.4870183, 0.5271342, 0.4835674, 0.524497, 0.4838107, 0.5233449, 0.4879927, 0.5431939, 0.3723191, 0.5495997, 0.381724, 0.5473205, 0.3909471, 0.5416411, 0.406121, 0.5444934, 0.4034269, 0.5400963, 0.4151862, 0.539862, 0.4174325, 0.541086, 0.4186783, 0.540774, 0.413666, 0.5635812, 0.3914773, 0.5660501, 0.3830538, 0.5619761, 0.3776732, 0.5588365, 0.3884727, 0.5243092, 0.4965218, 0.5233352, 0.492382, 0.5221278, 0.5368522, 0.5277541, 0.4957747, 0.5280541, 0.49192, 0.5313609, 0.4940116, 0.5227656, 0.4903239, 0.5489181, 0.3690597, 0.5476882, 0.3965708, 0.5360892, 0.4149359, 0.538241, 0.4148898, 0.5613752, 0.4094034, 0.5601146, 0.4082556, 0.5611107, 0.3977669, 0.5588834, 0.40301, 0.5557498, 0.3790313, 0.5529415, 0.3892972, 0.5518373, 0.3953394, 0.5475575, 0.4018274, 0.541853, 0.4094443, 0.5441121, 0.4066617, 0.5563182, 0.3955903, 0.5548458, 0.401416, 0.5506461, 0.4008966, 0.5469319, 0.4051024, 0.5559503, 0.4085247, 0.5568658, 0.4061441, 0.5712565, 0.3248812, 0.5646648, 0.3137476, 0.5635974, 0.3269503, 0.5704071, 0.3366934, 0.5501015, 0.4042995, 0.5532446, 0.4044772, 0.5575014, 0.3051469, 0.5565349, 0.3204819, 0.5498636, 0.2987233, 0.5426151, 0.3127264, 0.5493563, 0.3164421, 0.543493, 0.2940484, 0.5361611, 0.2911223, 0.5286502, 0.2897139, 0.5286111, 0.3100734, 0.535626, 0.3110899, 0.5354849, 0.3329006, 0.5367749, 0.3540221, 0.5437511, 0.3536135, 0.5424639, 0.3339317, 0.5503391, 0.3538301, 0.5491936, 0.3351072, 0.5553176, 0.3372701, 0.5560855, 0.3548355, 0.5617746, 0.3570887, 0.5621883, 0.3419062, 0.5681202, 0.3634121, 0.5691422, 0.3498532, 0.5744593, 0.3572085, 0.5734909, 0.3698592, 0.5766734, 0.3759404, 0.5776547, 0.3667778, 0.5397283, 0.5823174, 0.5375824, 0.4862982, 0.5362434, 0.4829016, 0.537752, 0.4896439, 0.5329767, 0.430925, 0.5344603, 0.4665406, 0.5343286, 0.4704378, 0.5375512, 0.4717314, 0.5347168, 0.4763054, 0.533744, 0.4801357, 0.532106, 0.4827065, 0.5595948, 0.4739665, 0.5533608, 0.4699152, 0.5578752, 0.4624499, 0.5565332, 0.4508398, 0.555797, 0.424888, 0.5597445, 0.4310549, 0.5573573, 0.4325854, 0.5588498, 0.4420931, 0.5703204, 0.5281214, 0.5659875, 0.5345811, 0.5736385, 0.5205466, 0.5747253, 0.5072823, 0.5708818, 0.5138186, 0.5798252, 0.4511784, 0.5781572, 0.4609022, 0.5669605, 0.5209817, 0.5579575, 0.5843741, 0.5650615, 0.4748314, 0.574948, 0.4679338, 0.570428, 0.4732925, 0.5480167, 0.4638438, 0.5371903, 0.4686273, 0.5341378, 0.4624541, 0.5261377, 0.4506657, 0.5292839, 0.453405, 0.5619371, 0.4286848, 0.5668971, 0.4329819, 0.5634984, 0.4254736, 0.5708497, 0.4406603, 0.5633011, 0.4629514, 0.578222, 0.4022973, 0.5763182, 0.3940251, 0.5746107, 0.3868785, 0.5715196, 0.380744, 0.5672848, 0.3745866, 0.5618456, 0.3700481, 0.5557556, 0.3685603, 0.5287197, 0.3324265, 0.5299526, 0.3545161, 0.5405277, 0.5176077, 0.5387474, 0.5255486, 0.5318743, 0.4572307, 0.5354875, 0.5338392, 0.5372584, 0.5308462, 0.5336704, 0.5297548, 0.530713, 0.5398543, 0.5296853, 0.5372654, 0.5357482, 0.4215894, 0.538304, 0.4269875, 0.5401151, 0.4231007, 0.5382764, 0.4196799, 0.5303711, 0.4238257, 0.5426009, 0.4498205, 0.5431009, 0.4571821, 0.5395764, 0.4148563, 0.5834417, 0.4609509, 0.5846504, 0.4478751, 0.5840453, 0.4468893, 0.5428923, 0.478718, 0.532356, 0.4992159, 0.5280179, 0.4869336, 0.5304285, 0.4867563, 0.5637106, 0.4177105, 0.5627658, 0.4194372, 0.5625898, 0.4110287, 0.5615259, 0.4214101, 0.5617488, 0.4123843, 0.5765562, 0.3371591, 0.5754198, 0.3466121, 0.5636509, 0.4123888, 0.5652581, 0.4110667, 0.5628317, 0.4135671, 0.5312036, 0.6149903, 0.531932, 0.6131843, 0.5371228, 0.6127535, 0.542837, 0.6081753, 0.5486658, 0.6010878, 0.5439058, 0.6049637, 0.5495526, 0.5981852, 0.5367565, 0.5096841, 0.5377658, 0.6103479, 0.5611517, 0.4505731, 0.5649062, 0.5657865, 0.5759428, 0.5145612, 0.5751426, 0.4508975, 0.5690358, 0.4167303, 0.5689657, 0.4132426, 0.5657196, 0.4156289, 0.565798, 0.4131947, 0.5638857, 0.4152, 0.5642308, 0.4139138, 0.563158, 0.4145705, 0.5780187, 0.5094242, 0.5802804, 0.4419051, 0.5657991, 0.4177245, 0.5637816, 0.4163691, 0.5691471, 0.4202103, 0.5732906, 0.4243901, 0.5771165, 0.4290693, 0.5324523, 0.5063815, 0.5398077, 0.4828636, 0.5390486, 0.4870062, 0.5827327, 0.445164, 0.5795554, 0.496473, 0.578302, 0.5078796, 0.5792743, 0.3584121, 0.5801144, 0.3496723, 0.5845098, 0.4490735, 0.5836676, 0.4626383, 0.5795454, 0.4940196, 0.5658286, 0.5609515, 0.5324402, 0.612609, 0.5385247, 0.6086425, 0.5444301, 0.6028069, 0.55005, 0.5955576, 0.5451736, 0.6018941, 0.5510282, 0.5932022, 0.5390758, 0.6083665, 0.5327618, 0.612588, 0.5558491, 0.586293, 0.5550768, 0.5903852, 0.5615698, 0.5725192, 0.5566036, 0.5831088, 0.5519897, 0.5944673, 0.5538323, 0.5928596, 0.5597582, 0.5811321, 0.5606762, 0.576721, 0.5787582, 0.384868, 0.5793825, 0.4117688, 0.5804017, 0.3784744, 0.5804146, 0.3950736, 0.5818647, 0.4083439, 0.5831772, 0.4056332, 0.5822558, 0.3908356, 0.5822518, 0.3717829, 0.5835926, 0.3868541, 0.5845874, 0.4032173, 0.5836773, 0.364614, 0.5853587, 0.383175, 0.5858078, 0.4016901, 0.5848353, 0.4340821, 0.5843535, 0.4338335, 0.5829941, 0.4334987, 0.5848421, 0.4347096, 0.5852298, 0.4191881, 0.5851035, 0.4194892, 0.5802606, 0.4227118, 0.5801997, 0.4322497, 0.5827216, 0.4214182, 0.584189, 0.4202726, 0.5634772, 0.415421, 0.5197359, 0.5369997, 0.4583778, 0.5068961, 0.5777161, 0.5075548, 0.502626, 0.4118313, 0.5033606, 0.4093405, 0.5048746, 0.4071292, 0.5067179, 0.4023493, 0.5063164, 0.3860551, 0.5106424, 0.3849634, 0.5151739, 0.3841058, 0.522168, 0.3834235, 0.5295941, 0.3843753, 0.533851, 0.3852867, 0.5377382, 0.3869424, 0.536432, 0.4032672, 0.5383842, 0.4077689, 0.5396618, 0.409783, 0.5406466, 0.4122177, 0.5503139, 0.4210043, 0.5477709, 0.420538, 0.5528767, 0.4219434, 0.5595254, 0.4210685, 0.5574946, 0.421545, 0.5432421, 0.4196312, 0.5456077, 0.4204268, 0.5412104, 0.4176269, 0.5402436, 0.4166548, 0.5552586, 0.4218442, 0.561046, 0.4199886, 0.5624038, 0.4185614, 0.5632523, 0.4170595, 0.4956585, 0.4200877, 0.4931162, 0.4204958, 0.4905093, 0.4213853, 0.4855783, 0.420877, 0.4839092, 0.4203625, 0.4980131, 0.420026, 0.5001489, 0.4192584, 0.5026253, 0.4163311, 0.5017091, 0.4172886, 0.487838, 0.4212306, 0.4822176, 0.4192647, 0.4807136, 0.4178238, 0.479906, 0.4163157, 0.4798581, 0.4146761, 0.5635102, 0.4160537, 0.5087829, 0.4895828, 0.5334318, 0.4898997, 0.5027537, 0.5494763, 0.5029608, 0.5521043, 0.5033947, 0.5446413, 0.5054271, 0.5542566, 0.5059005, 0.542233, 0.5078379, 0.5552969, 0.5172222, 0.53539, 0.5156815, 0.5542045, 0.5140924, 0.5538771, 0.5144562, 0.5358385, 0.5182376, 0.5357537, 0.5181753, 0.5548515, 0.5200287, 0.5359385, 0.5198354, 0.5552152, 0.5103521, 0.5547959, 0.5087439, 0.5392429, 0.5116839, 0.5370713, 0.5122734, 0.5538267, 0.5026819, 0.5507396, 0.5373921, 0.5525023, 0.5343554, 0.5550443, 0.5351055, 0.5449135, 0.537469, 0.5498264, 0.5321068, 0.5556412, 0.5329322, 0.5424261, 0.5240263, 0.5356678, 0.5264354, 0.5358913, 0.5255901, 0.5541554, 0.5240576, 0.5544809, 0.5216042, 0.5550348, 0.521844, 0.5359309, 0.5295618, 0.5550468, 0.5274788, 0.5539902, 0.5288002, 0.5373145, 0.5298833, 0.5396045, 0.5376389, 0.5513722, 0.5527357, 0.5235351, 0.5497284, 0.5100029, 0.5460128, 0.496176, 0.541998, 0.4836728, 0.5395126, 0.473661, 0.536607, 0.4650624, 0.5338036, 0.4582247, 0.531576, 0.4525116, 0.52891, 0.4483292, 0.5260049, 0.4453711, 0.5218478, 0.4438469, 0.5179533, 0.4452924, 0.5141438, 0.448189, 0.5111865, 0.4523258, 0.5086368, 0.4579735, 0.5062292, 0.464823, 0.503338, 0.4733628, 0.5008594, 0.4832344, 0.4965645, 0.4954289, 0.492667, 0.5092871, 0.489552, 0.5226968, 0.4872328, 0.5464215, 0.4883528, 0.554508, 0.4900365, 0.5635618, 0.4948212, 0.5787479, 0.497712, 0.5850506, 0.5010067, 0.5922208, 0.5050531, 0.600437, 0.5100561, 0.6056031, 0.5149924, 0.6082311, 0.5195129, 0.6091244, 0.5240074, 0.6092457, 0.5283002, 0.6090651, 0.5331287, 0.6080878, 0.5376601, 0.6053683, 0.5420576, 0.6001285, 0.5451907, 0.5919247, 0.5475647, 0.5847812, 0.5499584, 0.578474, 0.5537446, 0.5636961, 0.5547469, 0.554939, 0.5553046, 0.5471271, 0.5610136, 0.5070724, 0.5543861, 0.4947012, 0.5486047, 0.4826158, 0.5434361, 0.4720149, 0.5394215, 0.4633727, 0.536596, 0.4556239, 0.5337607, 0.4488069, 0.5310119, 0.4433226, 0.5290034, 0.4389937, 0.5264088, 0.4362451, 0.5221402, 0.4349245, 0.4806897, 0.5062191, 0.4883043, 0.4940712, 0.49435, 0.4820366, 0.4996236, 0.4716062, 0.5034463, 0.4630841, 0.5065891, 0.4553649, 0.5092215, 0.4486717, 0.5115334, 0.4431579, 0.5144941, 0.4388807, 0.5181693, 0.4361917, 0.4791052, 0.5253577, 0.4803289, 0.5389416, 0.480542, 0.5509042, 0.4823586, 0.5618778, 0.4892971, 0.5787134, 0.4933597, 0.5866561, 0.4971023, 0.5946348, 0.5020332, 0.6029698, 0.507691, 0.6092846, 0.5136751, 0.6134908, 0.5190343, 0.6151625, 0.5242681, 0.615406, 0.5292386, 0.6151244, 0.5348917, 0.6133552, 0.540104, 0.6090779, 0.5451223, 0.6026797, 0.5493057, 0.5942067, 0.5525607, 0.5863084, 0.5553161, 0.5784409, 0.5596144, 0.5620501, 0.5610073, 0.5512679, 0.561103, 0.5395175, 0.5620305, 0.5266752, 0.5718309, 0.4859196, 0.5757749, 0.4801419, 0.5818645, 0.4734373, 0.5821124, 0.4729412, 0.5801178, 0.4720601, 0.5817, 0.4727285, 0.5673904, 0.4894536, 0.4654961, 0.4791279, 0.4696864, 0.4849466, 0.4573932, 0.4715013, 0.4606809, 0.4709173, 0.4603453, 0.4717718, 0.4630397, 0.4722548, 0.4744059, 0.4885596, 0.561269, 0.4883101, 0.4809552, 0.4875771, 0.5485533, 0.4732753, 0.5435637, 0.4648915, 0.5547543, 0.4816715, 0.5365488, 0.45027, 0.5393784, 0.4571332, 0.5339056, 0.444122, 0.5311126, 0.438176, 0.5292256, 0.4339243, 0.5264324, 0.4309646, 0.5223045, 0.4302774, 0.4996813, 0.4645074, 0.4944561, 0.4727449, 0.5038351, 0.4568586, 0.4878777, 0.481077, 0.5119643, 0.4380915, 0.5092527, 0.4439438, 0.5148541, 0.4338225, 0.5183828, 0.4309062, 0.5068038, 0.450078, 0.4695033, 0.4974875, 0.4640847, 0.4922612, 0.4729261, 0.5024095, 0.4908738, 0.5374873, 0.4874466, 0.5353615, 0.4832028, 0.5313781, 0.5758902, 0.493218, 0.5719799, 0.4983264, 0.5787039, 0.4889306, 0.5680061, 0.5032031, 0.5487326, 0.5407127, 0.5514817, 0.5380033, 0.5548095, 0.5364524, 0.5582505, 0.5326347, 0.5809835, 0.4832897, 0.5805432, 0.4843859, 0.5803602, 0.4860713, 0.4604314, 0.4877635, 0.4580297, 0.4849604, 0.459071, 0.4833651, 0.4620646, 0.4822244, 0.4936857, 0.5402423, 0.5445773, 0.5460666, 0.5469774, 0.5434172, 0.5390962, 0.5475295, 0.5411624, 0.5468844, 0.4991697, 0.54641, 0.5006048, 0.5471017, 0.4969417, 0.5454779, 0.4952953, 0.5430259, 0.4711153, 0.548646, 0.4706445, 0.5538214, 0.4723067, 0.5594782, 0.476024, 0.5645362, 0.4805974, 0.5683532, 0.4854551, 0.5709531, 0.4886703, 0.5725298, 0.4921689, 0.5716504, 0.4955575, 0.5689302, 0.4975197, 0.5656396, 0.4984719, 0.5634059, 0.4997057, 0.5604833, 0.501426, 0.5573854, 0.5024849, 0.5557006, 0.503545, 0.5532203, 0.5041239, 0.5520828, 0.5039898, 0.5527912, 0.5026355, 0.5473312, 0.5025572, 0.5481459, 0.5014233, 0.5478001, 0.5693064, 0.5487654, 0.5684208, 0.5538142, 0.5667068, 0.559325, 0.5644281, 0.5644251, 0.5615303, 0.5682683, 0.5579739, 0.5708986, 0.5555829, 0.5725013, 0.5521848, 0.5716137, 0.5489581, 0.568872, 0.5466893, 0.5657113, 0.5456592, 0.5634117, 0.5440918, 0.5604779, 0.541908, 0.5576094, 0.5395451, 0.5557418, 0.5370732, 0.5536554, 0.5363716, 0.5525007, 0.5362676, 0.5533436, 0.5365351, 0.5476814, 0.5368583, 0.5484779, 0.5379981, 0.5481943 };
	
	//variable to change uv's
	private bool changeUV= false;

	//start uv's
	private int currentUV = -1;

	//vector for uvs
	private Vector2[] fixedUVs = new Vector2[1347];

	//index of the player to track
	//made private to allow ease of switching
	private int playerIndex = 0;
	
	[Tooltip("Whether to poll the HD-face model data or not.")]
	public bool getFaceModelData = false;

	[Tooltip("Whether to display the face rectangle over the color camera feed.")]
	public bool displayFaceRect = false;
	
	[Tooltip("Time tolerance in seconds, when the face may not to be tracked, without considering it lost.")]
	public float faceTrackingTolerance = 0.5f;
	
	[Tooltip("Game object that will be used to display the HD-face model mesh in the scene.")]
	public GameObject faceModelMesh = null;
	
	[Tooltip("Whether the HD-face model mesh should be mirrored or not.")]
	private bool mirroredModelMesh = true;

	//[Tooltip("Whether to skip the continuous updates of the HD-face model mesh, or not.")]
	//never skip updates. this is why we are using it
	//public bool dontUpdateModelMesh = false;

	[Tooltip("Whether to pause the updates of the HD-face model mesh.")]
	public bool pauseModelMeshUpdates = false;

	public enum TextureType : int { None, ColorMap, FaceRectangle }
	[Tooltip("How the HD-face model mesh should be textured.")]
	public TextureType texturedModelMesh = TextureType.ColorMap;

	[Tooltip("Whether to move the face model mesh, to be the same as user's head position.")]
	public bool moveModelMesh = false;

	[Tooltip("Camera used to overlay face mesh over the color background.")]
	public Camera foregroundCamera;

	[Tooltip("Scale factor for the face mesh.")]
	[Range(0.1f, 2.0f)]
	public float modelMeshScale = 1f;

	[Tooltip("Vertical offset of the mesh above the head (in meters).")]
	[Range(-0.5f, 0.5f)]
	public float verticalMeshOffset = 0f;

	[Tooltip("UI-Text to display the FT-manager debug messages.")]
	public UnityEngine.UI.Text debugText;

//	// nose and head transforms
//	public Transform noseTransform;
//	public Transform headTransform;
//	public UnityEngine.UI.Text debugText2;


	// Is currently tracking user's face
	private bool isTrackingFace = false;
	private float lastFaceTrackedTime = 0f;
	
	// Skeleton ID of the tracked face
	//private long faceTrackingID = 0;
	
	// Animation units
	private Dictionary<KinectInterop.FaceShapeAnimations, float> dictAU = new Dictionary<KinectInterop.FaceShapeAnimations, float>();
	private bool bGotAU = false;

	// Shape units
	private Dictionary<KinectInterop.FaceShapeDeformations, float> dictSU = new Dictionary<KinectInterop.FaceShapeDeformations, float>();
	private bool bGotSU = false;

	// whether the face model mesh was initialized
	private bool bFaceModelMeshInited = false;
	private Vector3[] vMeshVertices = null;

	// Vertices, UV and triangles of the face model
	private Vector3[] avModelVertices = null;
	private Vector2[] avModelUV = null;
	private bool bGotModelVertices = false;
	//private bool bGotModelVerticesFromDC = false;
	private bool bGotModelUV = false;

	private int[] avModelTriangles = null;
	private bool bGotModelTriangles = false;
	private bool bGotModelTrianglesFromDC = false;

	// Head position and rotation
	private Vector3 headPos = Vector3.zero;
	private bool bGotHeadPos = false;

	private Quaternion headRot = Quaternion.identity;
	private bool bGotHeadRot = false;

	// offset vector from head to face center
	private Vector3 faceHeadOffset = Vector3.zero;
	
	// Tracked face rectangle
	private Rect faceRect = new Rect();
	//private bool bGotFaceRect;

	// primary user ID, as reported by KinectManager
	private long primaryUserID = 0;
	private long lastUserID = 0;

	// primary sensor data structure
	private KinectInterop.SensorData sensorData = null;
	
	// Bool to keep track of whether face-tracking system has been initialized
	private bool isFacetrackingInitialized = false;
	private bool wasFacetrackingActive = false;
	
	// The single instance of FacetrackingManager
	private static FacetrackingWithUVs instance;

	// update times
	private float facePosUpdateTime = 0f;
	private float faceMeshUpdateTime = 0f;

	// used when dontUpdateModelMesh is true
	//private bool faceMeshGotOnce = false;

	// whether UpdateFaceModelMesh() is running
	private bool updateFaceMeshStarted = false;

	private Material faceMeshMaterial = null;
	private RenderTexture faceMeshTexture = null;
	private Vector3 nosePos = Vector3.zero;

	/// <summary>
	/// Gets the single FacetrackingManager instance.
	/// </summary>
	/// <value>The FacetrackingManager instance.</value>
    public static FacetrackingWithUVs Instance
    {
        get
        {
            return instance;
        }
    }
	
	/// <summary>
	/// Determines the facetracking system was successfully initialized, false otherwise.
	/// </summary>
	/// <returns><c>true</c> if the facetracking system was successfully initialized; otherwise, <c>false</c>.</returns>
	public bool IsFaceTrackingInitialized()
	{
		return isFacetrackingInitialized;
	}
	
	/// <summary>
	/// Determines whether this the sensor is currently tracking a face.
	/// </summary>
	/// <returns><c>true</c> if the sensor is tracking a face; otherwise, <c>false</c>.</returns>
	public bool IsTrackingFace()
	{
		return isTrackingFace;
	}

	/// <summary>
	/// Gets the current user ID, or 0 if no user is currently tracked.
	/// </summary>
	/// <returns>The face tracking I.</returns>
	public long GetFaceTrackingID()
	{
		return isTrackingFace ? primaryUserID : 0;
	}
	
	/// <summary>
	/// Determines whether the sensor is currently tracking the face of the specified user.
	/// </summary>
	/// <returns><c>true</c> if the sensor is currently tracking the face of the specified user; otherwise, <c>false</c>.</returns>
	/// <param name="userId">User ID</param>
	public bool IsTrackingFace(long userId)
	{
		if (userId != 0 && userId == primaryUserID) 
		{
			return isTrackingFace;
		}

		if(sensorData != null && sensorData.sensorInterface != null)
		{
			return sensorData.sensorInterface.IsFaceTracked(userId);
		}

		return false;
	}

	/// <summary>
	/// Gets the last face position & rotation update time, in seconds since game start.
	/// </summary>
	/// <returns>The last face position & rotation update time.</returns>
	public float GetFacePosUpdateTime()
	{
		return facePosUpdateTime;
	}

	/// <summary>
	/// Gets the last face mesh update time, in seconds since game start.
	/// </summary>
	/// <returns>The last face mesh update time.</returns>
	public float GetFaceMeshUpdateTime()
	{
		return faceMeshUpdateTime;
	}
	
	/// <summary>
	/// Gets the head position of the currently tracked user.
	/// </summary>
	/// <returns>The head position.</returns>
	/// <param name="bMirroredMovement">If set to <c>true</c> returns mirorred head position.</param>
	public Vector3 GetHeadPosition(bool bMirroredMovement)
	{
		Vector3 vHeadPos = headPos; // bGotHeadPos ? headPos : Vector3.zero;

		if(!bMirroredMovement)
		{
			vHeadPos.z = -vHeadPos.z;
		}
		
		return vHeadPos;
	}
	
	/// <summary>
	/// Gets the head position of the specified user.
	/// </summary>
	/// <returns>The head position.</returns>
	/// <param name="userId">User ID</param>
	/// <param name="bMirroredMovement">If set to <c>true</c> returns mirorred head position.</param>
	public Vector3 GetHeadPosition(long userId, bool bMirroredMovement)
	{
		if (userId != 0 && userId == primaryUserID) 
		{
			return GetHeadPosition(bMirroredMovement);
		}

		Vector3 vHeadPos = Vector3.zero;
		bool bGotPosition = sensorData.sensorInterface.GetHeadPosition(userId, ref vHeadPos);

		if(bGotPosition)
		{
			if(!bMirroredMovement)
			{
				vHeadPos.z = -vHeadPos.z;
			}
			
			return vHeadPos;
		}

		return Vector3.zero;
	}
	
	/// <summary>
	/// Gets the head rotation of the currently tracked user.
	/// </summary>
	/// <returns>The head rotation.</returns>
	/// <param name="bMirroredMovement">If set to <c>true</c> returns mirorred head rotation.</param>
	public Quaternion GetHeadRotation(bool bMirroredMovement)
	{
		Vector3 rotAngles = headRot.eulerAngles; // bGotHeadRot ? headRot.eulerAngles : Vector3.zero;

		if(bMirroredMovement)
		{
			rotAngles.x = -rotAngles.x;
			rotAngles.z = -rotAngles.z;
		}
		else
		{
			rotAngles.x = -rotAngles.x;
			rotAngles.y = -rotAngles.y;
		}
		
		return Quaternion.Euler(rotAngles);
	}
	
	/// <summary>
	/// Gets the head rotation of the specified user.
	/// </summary>
	/// <returns>The head rotation.</returns>
	/// <param name="userId">User ID</param>
	/// <param name="bMirroredMovement">If set to <c>true</c> returns mirorred head rotation.</param>
	public Quaternion GetHeadRotation(long userId, bool bMirroredMovement)
	{
		if (userId != 0 && userId == primaryUserID) 
		{
			return GetHeadRotation(bMirroredMovement);
		}

		Quaternion vHeadRot = Quaternion.identity;
		bool bGotRotation = sensorData.sensorInterface.GetHeadRotation(userId, ref vHeadRot);

		if(bGotRotation)
		{
			Vector3 rotAngles = vHeadRot.eulerAngles;
			
			if(bMirroredMovement)
			{
				rotAngles.x = -rotAngles.x;
				rotAngles.z = -rotAngles.z;
			}
			else
			{
				rotAngles.x = -rotAngles.x;
				rotAngles.y = -rotAngles.y;
			}
			
			return Quaternion.Euler(rotAngles);
		}

		return Quaternion.identity;
	}

	/// <summary>
	/// Gets the tracked face rectangle of the specified user in color image coordinates, or zero-rect if the user's face is not tracked.
	/// </summary>
	/// <returns>The face rectangle, in color image coordinates.</returns>
	/// <param name="userId">User ID</param>
	public Rect GetFaceColorRect(long userId)
	{
		Rect faceColorRect = new Rect();
		sensorData.sensorInterface.GetFaceRect(userId, ref faceColorRect);

		return faceColorRect;
	}
	
	/// <summary>
	/// Determines whether there are valid anim units.
	/// </summary>
	/// <returns><c>true</c> if there are valid anim units; otherwise, <c>false</c>.</returns>
	public bool IsGotAU()
	{
		return bGotAU;
	}
	
	/// <summary>
	/// Gets the animation unit value at given index, or 0 if the index is invalid.
	/// </summary>
	/// <returns>The animation unit value.</returns>
	/// <param name="faceAnimKey">Face animation unit.</param>
	public float GetAnimUnit(KinectInterop.FaceShapeAnimations faceAnimKey)
	{
		if(dictAU.ContainsKey(faceAnimKey))
		{
			return dictAU[faceAnimKey];
		}
		
		return 0.0f;
	}
	
	/// <summary>
	/// Gets all animation units for the specified user.
	/// </summary>
	/// <returns><c>true</c>, if the user's face is tracked, <c>false</c> otherwise.</returns>
	/// <param name="userId">User ID</param>
	/// <param name="dictAnimUnits">Animation units dictionary, to get the results.</param>
	public bool GetUserAnimUnits(long userId, ref Dictionary<KinectInterop.FaceShapeAnimations, float> dictAnimUnits)
	{
		if (userId != 0 && userId == primaryUserID) 
		{
			dictAnimUnits = dictAU;
			return bGotAU;
		}

		if(sensorData != null && sensorData.sensorInterface != null)
		{
			bool bGotIt = sensorData.sensorInterface.GetAnimUnits(userId, ref dictAnimUnits);
			return bGotIt;
		}

		return false;
	}
	
	/// <summary>
	/// Determines whether there are valid shape units.
	/// </summary>
	/// <returns><c>true</c> if there are valid shape units; otherwise, <c>false</c>.</returns>
	public bool IsGotSU()
	{
		return bGotSU;
	}
	
	/// <summary>
	/// Gets the shape unit value at given index, or 0 if the index is invalid.
	/// </summary>
	/// <returns>The shape unit value.</returns>
	/// <param name="faceShapeKey">Face shape unit.</param>
	public float GetShapeUnit(KinectInterop.FaceShapeDeformations faceShapeKey)
	{
		if(dictSU.ContainsKey(faceShapeKey))
		{
			return dictSU[faceShapeKey];
		}
		
		return 0.0f;
	}
	
	/// <summary>
	/// Gets all animation units for the specified user.
	/// </summary>
	/// <returns><c>true</c>, if the user's face is tracked, <c>false</c> otherwise.</returns>
	/// <param name="userId">User ID</param>
	/// <param name="dictShapeUnits">Shape units dictionary, to get the results.</param>
	public bool GetUserShapeUnits(long userId, ref Dictionary<KinectInterop.FaceShapeDeformations, float> dictShapeUnits)
	{
		if (userId != 0 && userId == primaryUserID) 
		{
			dictShapeUnits = dictSU;
			return bGotSU;
		}

		if(sensorData != null && sensorData.sensorInterface != null)
		{
			bool bGotIt = sensorData.sensorInterface.GetShapeUnits(userId, ref dictShapeUnits);
			return bGotIt;
		}
		
		return false;
	}
	
	/// <summary>
	/// Gets the count of face model vertices.
	/// </summary>
	/// <returns>The count of face model vertices.</returns>
	public int GetFaceModelVertexCount()
	{
		if (avModelVertices != null) 
		{
			return avModelVertices.Length;
		} 

		return 0;
	}

	/// <summary>
	/// Gets the face model vertex, if a face model is available and the index is in range; Vector3.zero otherwise.
	/// </summary>
	/// <returns>The face model vertex.</returns>
	/// <param name="index">Vertex index, or Vector3.zero</param>
	public Vector3 GetFaceModelVertex(int index)
	{
		if (avModelVertices != null) 
		{
			if(index >= 0 && index < avModelVertices.Length)
			{
				return avModelVertices[index];
			}
		}
		
		return Vector3.zero;
	}
	
	/// <summary>
	/// Gets all face model vertices, if a face model is available; null otherwise.
	/// </summary>
	/// <returns>The face model vertices, or null.</returns>
	public Vector3[] GetFaceModelVertices()
	{
		return avModelVertices;
	}

	/// <summary>
	/// Gets the count of face model vertices for the specified user
	/// </summary>
	/// <returns>The count of face model vertices.</returns>
	/// <param name="userId">User ID</param>
	public int GetUserFaceVertexCount(long userId)
	{
		if (userId != 0 && userId == primaryUserID) 
		{
			return GetFaceModelVertexCount();
		}

		if(sensorData != null && sensorData.sensorInterface != null)
		{
			int iVertCount = sensorData.sensorInterface.GetFaceModelVerticesCount(userId);
			return iVertCount;
		}

		return 0;
	}

	/// <summary>
	/// Gets all face model vertices for the specified user.
	/// </summary>
	/// <returns><c>true</c>, if the user's face is tracked, <c>false</c> otherwise.</returns>
	/// <param name="userId">User ID</param>
	/// <param name="avVertices">Reference to array of vertices, to get the result.</param>
	public bool GetUserFaceVertices(long userId, ref Vector3[] avVertices)
	{
		if (userId != 0 && userId == primaryUserID) 
		{
			avVertices = GetFaceModelVertices();
			return (avModelVertices != null);
		}

		if(sensorData != null && sensorData.sensorInterface != null)
		{
			bool bGotIt = sensorData.sensorInterface.GetFaceModelVertices(userId, ref avVertices);
			return bGotIt;
		}
		
		return false;
	}
	
	/// <summary>
	/// Gets the count of face model triangles.
	/// </summary>
	/// <returns>The count of face model triangles.</returns>
	public int GetFaceModelTriangleCount()
	{
		if (avModelTriangles != null) 
		{
			return avModelTriangles.Length;
		}

		return 0;
	}

	/// <summary>
	/// Gets the face model triangle indices, if a face model is available; null otherwise.
	/// </summary>
	/// <returns>The face model triangle indices, or null.</returns>
	/// <param name="bMirroredModel">If set to <c>true</c> gets mirorred model indices.</param>
	public int[] GetFaceModelTriangleIndices(bool bMirroredModel)
	{
		if (avModelTriangles != null) 
		{
			return avModelTriangles;
		}

		return null;
	}

	/// <summary>
	/// Gets the face model UV-array, if it is available; null otherwise
	/// </summary>
	/// <returns>The face model UV-array, or null.</returns>
	public Vector2[] GetFaceModelUV()
	{
		if (bGotModelUV) 
		{
			return avModelUV;
		}

		return null;
	}

	/// <summary>
	/// Resets the face model UV-array. This is to request new UV-array estimation, when the 'Textured model mesh' is set to FaceRectangle.
	/// </summary>
	public void ResetFaceModelUV()
	{
		bGotModelUV = false;
	}


	//----------------------------------- end of public functions --------------------------------------//

	void Awake()
	{
		instance = this;
	}

	void Start() 
	{
		for (int i = 0; i < fixedUVs.Length; i++) {
			//fixedUVs [i] = new Vector2 ((float)hardCodedUVs[i*2], (float)hardCodedUVs[i*2 + 1]);
			//fixedUVs [i] = new Vector2 ((float)oldUVs[i*2], (float)oldUVs[i*2 + 1]);
			fixedUVs [i] = new Vector2 ((float)finalUVs[i*2], (float)finalUVs[i*2 + 1]);
			// oldUVS are "contiguous" at least, but I'll have to manipulate them individually and have to figure out how to visualize them to map the photos
		}

		try 
		{
			// get sensor data
			KinectManager kinectManager = KinectManager.Instance;
			if(kinectManager && kinectManager.IsInitialized())
			{
				sensorData = kinectManager.GetSensorData();
			}

			if(sensorData == null || sensorData.sensorInterface == null)
			{
				throw new Exception("Face tracking cannot be started, because KinectManager is missing or not initialized.");
			}

			if(debugText != null)
			{
				debugText.text = "Please, wait...";
			}
			
			// ensure the needed dlls are in place and face tracking is available for this interface
			bool bNeedRestart = false;
			if(sensorData.sensorInterface.IsFaceTrackingAvailable(ref bNeedRestart))
			{
				if(bNeedRestart)
				{
					KinectInterop.RestartLevel(gameObject, "FM");
					return;
				}
			}
			else
			{
				string sInterfaceName = sensorData.sensorInterface.GetType().Name;
				throw new Exception(sInterfaceName + ": Face tracking is not supported!");
			}

			// Initialize the face tracker
			wasFacetrackingActive = sensorData.sensorInterface.IsFaceTrackingActive();
			if(!wasFacetrackingActive)
			{
				if (!sensorData.sensorInterface.InitFaceTracking(getFaceModelData, displayFaceRect))
				{
					throw new Exception("Face tracking could not be initialized.");
				}
			}

			isFacetrackingInitialized = true;

			//DontDestroyOnLoad(gameObject);

			if(debugText != null)
			{
				debugText.text = "Ready.";
			}
		} 
		catch(DllNotFoundException ex)
		{
			Debug.LogError(ex.ToString());
			if(debugText != null)
				debugText.text = "Please check the Kinect and FT-Library installations.";
		}
		catch (Exception ex) 
		{
			Debug.LogError(ex.ToString());
			if(debugText != null)
				debugText.text = ex.Message;
		}
	}

	void OnDestroy()
	{
		if(isFacetrackingInitialized && !wasFacetrackingActive && sensorData != null && sensorData.sensorInterface != null)
		{
			// finish face tracking
			sensorData.sensorInterface.FinishFaceTracking();
		}

		if (faceMeshTexture != null) 
		{
			faceMeshTexture.Release();
			faceMeshTexture = null;
		}

//		// clean up
//		Resources.UnloadUnusedAssets();
//		GC.Collect();
		
		isFacetrackingInitialized = false;
		instance = null;
	}
	
	void Update() 
	{
		if (Input.GetKeyDown(KeyCode.RightArrow)){
			startNumber++;
			print (startNumber.ToString());
		}
		if (Input.GetKeyDown(KeyCode.LeftArrow)){
			startNumber--;
			print (startNumber.ToString());
		}
		if(isFacetrackingInitialized)
		{
			KinectManager kinectManager = KinectManager.Instance;
			if(kinectManager && kinectManager.IsInitialized())
			{
				lastUserID = primaryUserID;
				primaryUserID = kinectManager.GetUserIdByIndex(playerIndex);

				if (primaryUserID != lastUserID && primaryUserID != 0) 
				{
					//faceMeshGotOnce = false;
				}
			}

			// update the face tracker
			isTrackingFace = false;

			bool bFacetrackingUpdated = !wasFacetrackingActive ? sensorData.sensorInterface.UpdateFaceTracking() : true;
			if(bFacetrackingUpdated)
			{
				// estimate the tracking state
				isTrackingFace = sensorData.sensorInterface.IsFaceTracked(primaryUserID);

				if(!isTrackingFace && (Time.realtimeSinceStartup - lastFaceTrackedTime) <= faceTrackingTolerance)
				{
					// allow tolerance in tracking
					isTrackingFace = true;
				}

				// get the facetracking parameters
				if(isTrackingFace)
				{
					lastFaceTrackedTime = Time.realtimeSinceStartup;
					facePosUpdateTime = Time.time;
					
					// get face rectangle
					/**bGotFaceRect =*/ sensorData.sensorInterface.GetFaceRect(primaryUserID, ref faceRect);
					
					// get head position
					bGotHeadPos = sensorData.sensorInterface.GetHeadPosition(primaryUserID, ref headPos);

					// get head rotation
					bGotHeadRot = sensorData.sensorInterface.GetHeadRotation(primaryUserID, ref headRot);

					// get the animation units
					bGotAU = sensorData.sensorInterface.GetAnimUnits(primaryUserID, ref dictAU);

					// get the shape units
					bGotSU = sensorData.sensorInterface.GetShapeUnits(primaryUserID, ref dictSU);

					//if(faceModelMesh != null && faceModelMesh.activeInHierarchy)
					{
						// apply model vertices to the mesh
						if(!bFaceModelMeshInited)
						{
							bFaceModelMeshInited = CreateFaceModelMesh();
						}
					}
					
					if (getFaceModelData && bFaceModelMeshInited && primaryUserID != 0) 
					{
						if (!pauseModelMeshUpdates && !updateFaceMeshStarted)
						{
							StartCoroutine(UpdateFaceModelMesh());
						}
					} 
				}
			}

//			// set mesh activity flag
//			bool bFaceMeshActive = isTrackingFace && primaryUserID != 0;
//			if(faceModelMesh != null && bFaceModelMeshInited && faceModelMesh.activeSelf != bFaceMeshActive)
//			{
//				faceModelMesh.SetActive(bFaceMeshActive);
//			}
		}
	}
	
	void OnGUI()
	{
		if(isFacetrackingInitialized)
		{
			if(debugText != null)
			{
				if(isTrackingFace)
				{
					debugText.text = "BodyID: " + primaryUserID;
				}
				else
				{
					debugText.text = "Not tracking...";
				}
			}
		}
	}


	protected bool CreateFaceModelMesh()
	{
//		if(faceModelMesh == null)
//			return false;

		if (avModelVertices == null /**&& !bGotModelVerticesFromDC*/) 
		{
			int iNumVertices = sensorData.sensorInterface.GetFaceModelVerticesCount(0);
			if(iNumVertices <= 0)
				return false;

			avModelVertices = new Vector3[iNumVertices];
			bGotModelVertices = sensorData.sensorInterface.GetFaceModelVertices(0, ref avModelVertices);

			avModelUV = new Vector2[iNumVertices];
			bGotModelUV = false;

			if(!bGotModelVertices)
				return false;
		}

		// estimate face mesh vertices with respect to the head joint
		Vector3[] vMeshVertices = new Vector3[avModelVertices.Length];

		//if (!bGotModelVerticesFromDC) 
		{
			Vector3 vFaceCenter = Vector3.zero;
			for (int i = 0; i < avModelVertices.Length; i++) 
			{
				vFaceCenter += avModelVertices[i];
			}

			vFaceCenter /= (float)avModelVertices.Length;

			faceHeadOffset = Vector3.zero;
			if (vFaceCenter.sqrMagnitude >= 1f) 
			{
				Vector3 vHeadToFace = (vFaceCenter - headPos);

				faceHeadOffset = Quaternion.Inverse(headRot) * vHeadToFace;
				faceHeadOffset.y += verticalMeshOffset;
			}

			vFaceCenter -= headRot * faceHeadOffset;

			for(int i = 0; i < avModelVertices.Length; i++)
			{
				//avModelVertices[i] = kinectToWorld.MultiplyPoint3x4(avModelVertices[i]) - headPosWorld;
				//avModelVertices[i] -= vFaceCenter;

				vMeshVertices[i] = avModelVertices[i] - vFaceCenter;
			}
		}

		if (avModelTriangles == null && !bGotModelTrianglesFromDC) 
		{
			int iNumTriangles = sensorData.sensorInterface.GetFaceModelTrianglesCount();
			if(iNumTriangles <= 0)
				return false;

			avModelTriangles = new int[iNumTriangles];
			bGotModelTriangles = sensorData.sensorInterface.GetFaceModelTriangles(mirroredModelMesh, ref avModelTriangles);

			if(!bGotModelTriangles)
				return false;
		}

		if (!faceMeshMaterial && faceModelMesh) 
		{
			faceMeshMaterial = faceModelMesh.GetComponent<MeshRenderer>().material;

			if (faceMeshMaterial && faceMeshMaterial.mainTexture) 
			{
				faceMeshMaterial.mainTexture.wrapMode = TextureWrapMode.Clamp;  // TextureWrapMode.Repeat; // 
			}
		}

		if (faceModelMesh) 
		{
			Mesh mesh = new Mesh();
			mesh.name = "FaceMesh";
			faceModelMesh.GetComponent<MeshFilter>().mesh = mesh;

			mesh.vertices = vMeshVertices; // avModelVertices;
			//mesh.uv = avModelUV;

			mesh.triangles = avModelTriangles;
			mesh.RecalculateNormals();

//			if (moveModelMesh) 
//			{
//				faceModelMesh.transform.position = headPos;
//				//faceModelMesh.transform.rotation = faceModelRot;
//			}

			SetFaceModelMeshTexture();
		}

		//bFaceModelMeshInited = true;
		return true;
	}

	// sets the proper face mesh texture
	protected void SetFaceModelMeshTexture()
	{
		if (texturedModelMesh == TextureType.ColorMap) 
		{
			KinectManager kinectManager = KinectManager.Instance;
			Texture texColorMap = kinectManager ? kinectManager.GetUsersClrTex() : null;

			if (!faceMeshTexture && kinectManager && texColorMap) 
			{
				faceMeshTexture = new RenderTexture (texColorMap.width, texColorMap.height, 0);
				faceMeshMaterial.mainTexture = faceMeshTexture;  // kinectManager.GetUsersClrTex();
			}

			if (faceMeshTexture && texColorMap) 
			{
				// update the color texture
				Graphics.Blit(texColorMap, faceMeshTexture);
			}
		}
		else if (texturedModelMesh == TextureType.FaceRectangle) 
		{
//			if (faceMeshTexture != null) 
//			{
//				faceMeshTexture.Release();
//				faceMeshTexture = null;
//			}
		}
		else if(texturedModelMesh == TextureType.None)
		{
			if (faceMeshMaterial.mainTexture != null) 
			{
				faceMeshMaterial.mainTexture = null;
			}

			if (faceMeshTexture != null) 
			{
				faceMeshTexture.Release();
				faceMeshTexture = null;
			}
		}
	}


	protected IEnumerator UpdateFaceModelMesh()
	{
		updateFaceMeshStarted = true;

		// init the vertices array if needed
		if(avModelVertices == null)
		{
			int iNumVertices = sensorData.sensorInterface.GetFaceModelVerticesCount(primaryUserID);
			avModelVertices = new Vector3[iNumVertices];
		}

		// get face model vertices
		bGotModelVertices = sensorData.sensorInterface.GetFaceModelVertices(primaryUserID, ref avModelVertices);								

		if(bGotModelVertices && faceModelMesh != null)
		{
			//Quaternion faceModelRot = faceModelMesh.transform.rotation;
			//faceModelMesh.transform.rotation = Quaternion.identity;

			bool bFaceMeshUpdated = false;
			//used if not updating hd model mesh
			//if (!dontUpdateModelMesh || !faceMeshGotOnce) 
			AsyncTask<bool> task = new AsyncTask<bool>(() => {
				// estimate face mesh vertices with respect to the head joint
				vMeshVertices = null;

				KinectManager kinectManager = KinectManager.Instance;
				Matrix4x4 kinectToWorld = kinectManager ? kinectManager.GetKinectToWorldMatrix() : Matrix4x4.identity;
				Vector3 headPosWorld = kinectToWorld.MultiplyPoint3x4(headPos);
					
				Vector3 lastNosePos = nosePos;
				//if (!bGotModelVerticesFromDC) 
				{
//						Vector3 vFaceCenter = Vector3.zero;
//						for (int i = 0; i < avModelVertices.Length; i++) 
//						{
//							vFaceCenter += avModelVertices[i];
//						}
//
//						vFaceCenter /= (float)avModelVertices.Length;
//
//						Vector3 vHeadToFace = (vFaceCenter - headPos);
//						if (vHeadToFace.sqrMagnitude < 0.015f) // max 0.12 x 0.12
//						{
//							faceHeadOffset = Quaternion.Inverse(headRot) * vHeadToFace;
//							faceHeadOffset.y += verticalMeshOffset;
//						}

					nosePos = GetFaceModelNosePos();
					Vector3 vHeadToNose = Quaternion.Inverse(headRot) * (nosePos - headPos);
					float headToNoseLen = vHeadToNose.magnitude;

//						string sHeadToNose = string.Format("({0:F2}, {0:F2}, {0:F2})", vHeadToNose.x, vHeadToNose.y, vHeadToNose.z);
//						Debug.Log("U-Face nosePos: " + nosePos + ", headPos: " + headPos + "\noffset: " + sHeadToNose + ", len: " + headToNoseLen);

					if(headToNoseLen >= 0.08f && headToNoseLen <= 0.18f)
					{
						//vFaceCenter -= headRot * faceHeadOffset;

						vMeshVertices = new Vector3[avModelVertices.Length];
						for(int i = 0; i < avModelVertices.Length; i++)
						{
							//avModelVertices[i] = kinectToWorld.MultiplyPoint3x4(avModelVertices[i]) - headPosWorld;
							//avModelVertices[i] -= vFaceCenter;

							//vMeshVertices[i] = avModelVertices[i] - vFaceCenter;
							vMeshVertices[i] = kinectToWorld.MultiplyPoint3x4(avModelVertices[i]) - headPosWorld; // avModelVertices[i] - headPos;
						}
					}	
				}

				if(vMeshVertices == null || lastNosePos == nosePos)
				{
					return false;
				}

				//if (!bGotModelVerticesFromDC) 
				{
					if(texturedModelMesh != TextureType.None)
					{
						float colorWidth = (float)kinectManager.GetColorImageWidth();
						float colorHeight = (float)kinectManager.GetColorImageHeight();

						//bool bGotFaceRect = sensorData.sensorInterface.GetFaceRect(userId, ref faceRect);
						bool faceRectValid = /**bGotFaceRect &&*/ faceRect.width > 0 && faceRect.height > 0;
						int lastValidUVIndex = -1;  // new code by Andrew Stern

						for(int i = 0; i < avModelVertices.Length; i++)
						{
							Vector2 posDepth = Vector2.zero;
							if(texturedModelMesh == TextureType.ColorMap || !bGotModelUV)
							{
								posDepth = kinectManager.MapSpacePointToDepthCoords(avModelVertices[i]);
							}

							bool bUvSet = false;
							if(posDepth != Vector2.zero)
							{
								ushort depth = kinectManager.GetDepthForPixel((int)posDepth.x, (int)posDepth.y);
								Vector2 posColor = kinectManager.MapDepthPointToColorCoords(posDepth, depth);

								if(posColor != Vector2.zero && !float.IsInfinity(posColor.x) && !float.IsInfinity(posColor.y))
								{
									if(texturedModelMesh == TextureType.ColorMap)
									{
										avModelUV[i] = new Vector2(posColor.x / colorWidth, posColor.y / colorHeight);
										lastValidUVIndex = i;   // new code by Andrew Stern
										bUvSet = true;
									}
									else if(texturedModelMesh == TextureType.FaceRectangle && faceRectValid)
									{
										if(!bGotModelUV)
										{
											avModelUV[i] = new Vector2(/**Mathf.Clamp01*/((posColor.x - faceRect.x) / faceRect.width), 
												/**Mathf.Clamp01*/(1f - (posColor.y - faceRect.y) / faceRect.height));
											lastValidUVIndex = i;   // new code by Andrew Stern
										}

										bUvSet = true;
									}
								}
							}

							if(texturedModelMesh == TextureType.ColorMap && !bUvSet)
							{
								if (lastValidUVIndex >= 0) // new code by Andrew Stern
								{
									avModelUV[i] = new Vector2(avModelUV[lastValidUVIndex].x, avModelUV[lastValidUVIndex].y);
								}
								else
								{
									// original code
									avModelUV[i] = Vector2.zero;
								}
							}
						}

						if(lastValidUVIndex >= 0)  // check for valid run
							bGotModelUV = true;
					}
				}

				return true;
			});

			task.Start();

			while (task.State == AsyncTaskState.Running)
			{
				yield return null;
			}

//				// show nose & head positions
//				Matrix4x4 kinectToWorld2 = KinectManager.Instance.GetKinectToWorldMatrix();
//				if (noseTransform)
//					noseTransform.position = kinectToWorld2.MultiplyPoint3x4(nosePos);
//				if(headTransform)
//					headTransform.position = kinectToWorld2.MultiplyPoint3x4(headPos);
//
//				Vector3 vHeadToNose2 = Quaternion.Inverse(headRot) * (nosePos - headPos);
//				string sHeadToNose2 = string.Format("({0:F2}, {0:F2}, {0:F2})", vHeadToNose2.x, vHeadToNose2.y, vHeadToNose2.z);
//				if(debugText2)
//					debugText2.text = "h2n: " + sHeadToNose2 + ", len: " + vHeadToNose2.magnitude;

			bFaceMeshUpdated = task.Result;
			if(bFaceMeshUpdated) 
			{
				Mesh mesh = faceModelMesh.GetComponent<MeshFilter>().mesh;
				mesh.vertices = vMeshVertices; // avModelVertices;
				vMeshVertices = null;

				if(texturedModelMesh != TextureType.None && avModelUV != null)
				{
					// Comment this block if you want to keep the original set of face UVs
					if (!changeUV)
					  mesh.uv = avModelUV;
					else
					  mesh.uv = fixedUVs;

					// NEW!
					// pregen UVs are 1443 in length, while avModelUV is 1347. Not sure how that happened :-(
					//Vector2[] destArray = new Vector2[1347];
					//Array.Copy(pregenFace.uv, startNumber, destArray, 0, 1347);
					//mesh.uv = destArray;
					//print (mesh.uv.Length.ToString () + ", " + pregenFace.uv.Length.ToString () + ", " + avModelUV.Length.ToString());

				}

				faceMeshUpdateTime = Time.time;
				//faceMeshGotOnce = true;

				mesh.RecalculateNormals();
				mesh.RecalculateBounds();

				// set the face mesh texture
				if (!changeUV)
				  SetFaceModelMeshTexture();
				else
				  faceMeshMaterial.mainTexture = faceImages[0];

				  
			}
		}

		if (moveModelMesh) 
		{
			KinectManager kinectManager = KinectManager.Instance;
			Matrix4x4 kinectToWorld = kinectManager ? kinectManager.GetKinectToWorldMatrix() : Matrix4x4.identity;
			Vector3 newHeadPos = kinectToWorld.MultiplyPoint3x4(headPos);

			// check for head pos overlay
			if(foregroundCamera)
			{
				// get the background rectangle (use the portrait background, if available)
				Rect backgroundRect = foregroundCamera.pixelRect;
				PortraitBackground portraitBack = PortraitBackground.Instance;

				if(portraitBack && portraitBack.enabled)
				{
					backgroundRect = portraitBack.GetBackgroundRect();
				}

				if(kinectManager)
				{
					Vector3 posColorOverlay = kinectManager.GetJointPosColorOverlay(primaryUserID, (int)KinectInterop.JointType.Head, foregroundCamera, backgroundRect);

					if(posColorOverlay != Vector3.zero)
					{
						newHeadPos = posColorOverlay;
					}
				}
			}
			// flip X for projection. Just inverting the cam's projection matrix won't do it - it's used to calculate the head position
			newHeadPos = new Vector3(-newHeadPos.x, newHeadPos.y, newHeadPos.z);
			faceModelMesh.transform.position = newHeadPos; // Vector3.Lerp(faceModelMesh.transform.position, newHeadPos, 20f * Time.deltaTime);
			//faceModelMesh.transform.rotation = faceModelRot;
		}

		// don't rotate the transform - mesh follows the head rotation
		if (faceModelMesh.transform.rotation != Quaternion.identity) 
		{
			faceModelMesh.transform.rotation = Quaternion.identity;
		}

		// apply scale factor
		if(faceModelMesh.transform.localScale.x != modelMeshScale)
		{
			faceModelMesh.transform.localScale = new Vector3(modelMeshScale, modelMeshScale, modelMeshScale);
		}

		if(!faceModelMesh.activeSelf)
		{
			faceModelMesh.SetActive(true);
		}
		else
		{
			if(faceModelMesh && faceModelMesh.activeSelf)
			{
				faceModelMesh.SetActive(false);
			}
		}

		updateFaceMeshStarted = false;
	}

	// returns the nose tip position, or Vector3.zero if not found
	private Vector3 GetFaceModelNosePos()
	{
		if (avModelVertices != null) 
		{
			int iNoseIndex = -1;
			if (sensorData.sensorIntPlatform == KinectInterop.DepthSensorPlatform.KinectSDKv2 ||
			    sensorData.sensorIntPlatform == KinectInterop.DepthSensorPlatform.KinectUWPv2 ||
			    sensorData.sensorIntPlatform == KinectInterop.DepthSensorPlatform.DummyK2) 
			{
				iNoseIndex = 18; // Microsoft.Kinect.Face.HighDetailFacePoints.NoseTip
			} 
			else if (sensorData.sensorIntPlatform == KinectInterop.DepthSensorPlatform.KinectSDKv1 ||
			        sensorData.sensorIntPlatform == KinectInterop.DepthSensorPlatform.DummyK1) 
			{
				iNoseIndex = 89; // 
			}

			if (iNoseIndex >= 0 && iNoseIndex < avModelVertices.Length) 
			{
				return avModelVertices[iNoseIndex];
			}
		}

		return Vector3.zero;
	}

	void LateUpdate(){
		//if (Input.GetKeyDown (KeyCode.Q)) {
		//	ObjExporter.MeshToFile (GetFaceModelVertices(), GetFaceModelUV(), GetFaceModelTriangleIndices(false), Application.persistentDataPath + "/derp.obj");
		//	print ("Saved to: " + Application.persistentDataPath + "/derp.obj");
		//	print("Verts:");
		//	print (GetFaceModelVertices().Length);
		//	print ("UVs");
		//	print (GetFaceModelUV ().Length);
		//	print ("indices");
		//	print (GetFaceModelTriangleIndices (false).Length);

		//}
		if (Input.GetKeyDown (KeyCode.Q)) {
			changeUV = !changeUV;
		}

	}



}
